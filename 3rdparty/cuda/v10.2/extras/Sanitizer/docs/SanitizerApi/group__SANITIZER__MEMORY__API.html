<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SanitizerApi: Sanitizer Memory API</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Sanitizer Memory API</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data passed to extended versions of Sanitizer memory APIs.  <a href="structSanitizer__MemoryData.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gac5a217ae4bf940257526d809985ecde">sanitizerAlloc</a> (void **devPtr, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory on the device.  <a href="#gac5a217ae4bf940257526d809985ecde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gf2e1a4070561ccc530f67f8431a82b74">sanitizerAllocEx</a> (void **devPtr, size_t size, <a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *memoryData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory on the device.  <a href="#gf2e1a4070561ccc530f67f8431a82b74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gfcf92fd8616420b88ce580777d330458">sanitizerFree</a> (void *devPtr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees memory on the device.  <a href="#gfcf92fd8616420b88ce580777d330458"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#g4de370e9a7fea1230469830d69115228">sanitizerFreeEx</a> (void *devPtr, <a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *memoryData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees memory on the device.  <a href="#g4de370e9a7fea1230469830d69115228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#g56ff2c521a8126f483d5be4db72c1bdc">sanitizerMemcpyDeviceToHost</a> (void *dst, void *src, size_t count, CUstream stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from device to host.  <a href="#g56ff2c521a8126f483d5be4db72c1bdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gdb1d0e48b16a34e9d79997d0c4fbe9f5">sanitizerMemcpyDeviceToHostEx</a> (void *dst, void *src, size_t count, CUstream stream, <a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *memoryData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from device to host.  <a href="#gdb1d0e48b16a34e9d79997d0c4fbe9f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gfd1d032cc6175d68c24a33ccb4923ec5">sanitizerMemcpyHostToDeviceAsync</a> (void *dst, void *src, size_t count, CUstream stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from host to device.  <a href="#gfd1d032cc6175d68c24a33ccb4923ec5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#gb02a5ddee19d9a46bbc7957ddbc3e017">sanitizerMemcpyHostToDeviceAsyncEx</a> (void *dst, void *src, size_t count, CUstream stream, <a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *memoryData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from host to device.  <a href="#gb02a5ddee19d9a46bbc7957ddbc3e017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#g59cb81da3bab3ae5849ffa0af5ff91a1">sanitizerMemset</a> (void *devPtr, int value, size_t count, CUstream stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes or sets device memory to a value.  <a href="#g59cb81da3bab3ae5849ffa0af5ff91a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#g04b4cf90d475fc4ae9a6f48241114c41">sanitizerMemsetEx</a> (void *devPtr, int value, size_t count, CUstream stream, <a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *memoryData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes or sets device memory to a value.  <a href="#g04b4cf90d475fc4ae9a6f48241114c41"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SANITIZER__MEMORY__API.html#g257fad19edaf98bbb4f59306a2ecc7f2">Sanitizer_MemoryData::perThreadStream</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions, types, and enums that implement the Sanitizer Memory API. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gac5a217ae4bf940257526d809985ecde"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerAlloc" ref="gac5a217ae4bf940257526d809985ecde" args="(void **devPtr, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerAlloc           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMalloc that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Pointer to allocated device memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Allocation size in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf2e1a4070561ccc530f67f8431a82b74"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerAllocEx" ref="gf2e1a4070561ccc530f67f8431a82b74" args="(void **devPtr, size_t size, Sanitizer_MemoryData *memoryData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerAllocEx           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *&nbsp;</td>
          <td class="paramname"> <em>memoryData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMalloc that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Pointer to allocated device memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Allocation size in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryData</em>&nbsp;</td><td>Extra parameters for the memory allocation </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gfcf92fd8616420b88ce580777d330458"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerFree" ref="gfcf92fd8616420b88ce580777d330458" args="(void *devPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerFree           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaFree that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Device pointer to memory to free </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4de370e9a7fea1230469830d69115228"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerFreeEx" ref="g4de370e9a7fea1230469830d69115228" args="(void *devPtr, Sanitizer_MemoryData *memoryData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerFreeEx           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *&nbsp;</td>
          <td class="paramname"> <em>memoryData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaFree that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Device pointer to memory to free </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryData</em>&nbsp;</td><td>Extra parameters for the memory free </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g56ff2c521a8126f483d5be4db72c1bdc"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemcpyDeviceToHost" ref="g56ff2c521a8126f483d5be4db72c1bdc" args="(void *dst, void *src, size_t count, CUstream stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemcpyDeviceToHost           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemcpy that can be called within a callback function. The function will return once the copy has completed. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Destination memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdb1d0e48b16a34e9d79997d0c4fbe9f5"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemcpyDeviceToHostEx" ref="gdb1d0e48b16a34e9d79997d0c4fbe9f5" args="(void *dst, void *src, size_t count, CUstream stream, Sanitizer_MemoryData *memoryData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemcpyDeviceToHostEx           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *&nbsp;</td>
          <td class="paramname"> <em>memoryData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemcpy that can be called within a callback function. The function will return once the copy has completed. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Destination memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryData</em>&nbsp;</td><td>Extra parameters for the data copy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gfd1d032cc6175d68c24a33ccb4923ec5"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemcpyHostToDeviceAsync" ref="gfd1d032cc6175d68c24a33ccb4923ec5" args="(void *dst, void *src, size_t count, CUstream stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemcpyHostToDeviceAsync           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemcpyAsync that can be called within a callback function. The function will return once the pageable buffer has been copied to the staging memory for DMA transfer to device memory, but the DMA to final destination may not have completed. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Destination memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb02a5ddee19d9a46bbc7957ddbc3e017"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemcpyHostToDeviceAsyncEx" ref="gb02a5ddee19d9a46bbc7957ddbc3e017" args="(void *dst, void *src, size_t count, CUstream stream, Sanitizer_MemoryData *memoryData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemcpyHostToDeviceAsyncEx           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *&nbsp;</td>
          <td class="paramname"> <em>memoryData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemcpyAsync that can be called within a callback function. The function will return once the pageable buffer has been copied to the staging memory for DMA transfer to device memory, but the DMA to final destination may not have completed. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Destination memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source memory address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryData</em>&nbsp;</td><td>Extra parameters for the data copy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g59cb81da3bab3ae5849ffa0af5ff91a1"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemset" ref="g59cb81da3bab3ae5849ffa0af5ff91a1" args="(void *devPtr, int value, size_t count, CUstream stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemset           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemset that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Pointer to device memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to set for each byte of specified memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g04b4cf90d475fc4ae9a6f48241114c41"></a><!-- doxytag: member="sanitizer_memory.h::sanitizerMemsetEx" ref="g04b4cf90d475fc4ae9a6f48241114c41" args="(void *devPtr, int value, size_t count, CUstream stream, Sanitizer_MemoryData *memoryData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SANITIZER__RESULT__API.html#g8edf13e06b1b4001d7577b07ddd575d8">SanitizerResult</a> SANITIZERAPI sanitizerMemsetEx           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUstream&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSanitizer__MemoryData.html">Sanitizer_MemoryData</a> *&nbsp;</td>
          <td class="paramname"> <em>memoryData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent of cudaMemset that can be called within a callback function. <dl class="note" compact><dt><b>Note:</b></dt><dd><b>Thread-safety</b>: this function is thread safe.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devPtr</em>&nbsp;</td><td>Pointer to device memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to set for each byte of specified memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Size in bytes to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Stream identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memoryData</em>&nbsp;</td><td>Extra parameters for the data memset </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g257fad19edaf98bbb4f59306a2ecc7f2"></a><!-- doxytag: member="Sanitizer_MemoryData::perThreadStream" ref="g257fad19edaf98bbb4f59306a2ecc7f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="group__SANITIZER__MEMORY__API.html#g257fad19edaf98bbb4f59306a2ecc7f2">Sanitizer_MemoryData::perThreadStream</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set to 1 if the API should use per-thread stream. This field is only used for memcpy/memset APIs. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 23 22:13:25 2019 for SanitizerApi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
